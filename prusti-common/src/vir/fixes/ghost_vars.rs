// Â© 2019, ETH Zurich
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! Fix ghost variables.

use std::collections::HashMap;
use std::mem;

use super::super::ast;
use super::super::cfg;

/// Viper has a consistency check that only variables declared inside
/// the package statement can be assigned in it. Since these ghost
/// variables are generated by method calls that happen outside the
/// package statement, it is hard to satisfy this requirement when
/// creating the encoding. Therefore, we fix this with an additional
/// pass that renames all variables declared inside package statements
/// so that they are unique.
pub fn fix_ghost_vars(
    mut method: cfg::CfgMethod
) -> cfg::CfgMethod {
    let mut fixer = GhostVarFixer::default();
    let mut sentinel_stmt = ast::Stmt::Comment(String::from("moved out stmt"));
    for block in &mut method.basic_blocks {
        for stmt in &mut block.stmts {
            mem::swap(&mut sentinel_stmt, stmt);
            sentinel_stmt = ast::StmtFolder::fold(&mut fixer, sentinel_stmt);
            mem::swap(&mut sentinel_stmt, stmt);
        }
    }
    method
}

#[derive(Default)]
struct GhostVarFixer {
    /// This is a stack of local variable replacements. The topmost mapping corresponds to the
    /// current package block, the next mapping corresponds to the parent package block, and so on.
    var_mappings: Vec<HashMap<ast::LocalVar, ast::LocalVar>>,
}

impl ast::StmtFolder for GhostVarFixer {
    fn fold_expr(&mut self, e: ast::Expr) -> ast::Expr {
        ast::ExprFolder::fold(self, e)
    }

    fn fold_package_magic_wand(
        &mut self,
        wand: ast::Expr,
        body: Vec<ast::Stmt>,
        label: String,
        vars: Vec<ast::LocalVar>,
        pos: ast::Position,
    ) -> ast::Stmt {
        let wand = self.fold_expr(wand);

        let fixed_vars = vars.iter()
            .cloned()
            .map(|var| {
                let mut fixed_var = var.clone();
                fixed_var.name.push_str(&format!("$p{}", self.var_mappings.len()));
                (var, fixed_var)
            })
            .collect::<HashMap<_, _>>();

        self.var_mappings.push(fixed_vars);

        let body = body.into_iter().map(|stmt| self.fold(stmt)).collect();

        let fixed_vars = self.var_mappings.pop().unwrap().into_iter()
            .map(|(_, fixed_var)| fixed_var)
            .collect();

        ast::Stmt::PackageMagicWand(wand, body, label, fixed_vars, pos)
    }
}

impl ast::ExprFolder for GhostVarFixer {
    fn fold_local(&mut self, local_var: ast::LocalVar, pos: ast::Position) -> ast::Expr {
        let fixed_var = self.var_mappings.iter().rev()
            .filter_map(|var_mapping| var_mapping.get(&local_var))
            .cloned()
            .next().unwrap_or(local_var);
        ast::Expr::Local(fixed_var, pos)
    }
}
